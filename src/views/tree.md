# Canvas绘制树形图
### 一. 思路  
1. 获取树的层数
2. 将数据扩展成完全树
3. 拆分为左右两棵树
4. 分配每层的位置
5. 由两棵树的叶子节点开始分配位置并逐层编辑父节点的位置
6. 绘制全部节点
7. 绘制节点间连接线
8. 实现切换功能
### 二.具体实现
首先我们要获取整棵树的深度, 方便下一步把所有分支扩展到同一深度. 处理树的时候会多次用到递归, 因此我们将其抽出做成一个单独的函数:
```
mapTree(fun) {
  // 可以自定义子节点的key值
  const { childKey } = this;
  const map = tree => {
    tree.forEach(child => {
      fun(child, tree);
      if (child[childKey]) {
        map(child[childKey]);
      }
    });
  };
  map(this.tree);
}
```  
然后递归获取整棵树的深度, 从根节点向下查询子节点, 如果子节点存在则继续向下查询, 同时把当前的深度记录在节点上, 使节点的格式变为:
```
node: {
  name: '',
  layer: '',
  child: []
}
```
获取到树的深度之后便开始扩展整棵树, 从根节点开始遍历, 如果当前节点的层数小于总层数, 且没有子节点, 则用空数据来填充子节点, 直到当前节点的层数等于树的深度.  
将所有分支扩展到最大深度后, 便可以将整棵树分成左右两部分, 定义两个数组:leftNameList和rightNameList, 分别保存左部分和右部分的根节点, 依据这两个数组来拆分出来左右两棵树. 将左/右每层的节点分别存入两个数组中leftTree和rightTree, 依据数组的index位置来区分层数.  
下一步就可以开始为每个节点分配位置了.先从左右每棵树的叶子节点开始, 平均分配到canvas的最左/最右列上, 然后从叶子节点开始遍历树, 为每个节点分配位置: 是叶子节点则平均分配y轴, 否则根据子节点的第一个和最后一个节点的位置来确定当前节点位置.  
接下来就是渲染节点了. 先清空canvas, 然后遍历树, 渲染每一个节点, 并在两个节点之间画连接线. 这里主要是文字的绘制, canvas绘制文字有两个属性: textAlign和textBaseline, 对应的效果如下图. 这里我们设置
```
ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
```
这样可以实现以每个节点的位置为中心来绘制.  
对于切换角色的功能, 最开始采用的是每次切换角色都重新绘制整个canvas, 优化后改为每次切换角色都遍历一次权限树, 只重新绘制新角色权限和就角色权限不同的节点, 可以提高效率.